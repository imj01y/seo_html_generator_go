# SEO HTML 生成器 - 缓存设计架构

## 概述

本项目实现了**多层次、分布式缓存系统**，包含 6 种主要缓存类型：

```
┌─────────────────────────────────────────────────────────────┐
│                    SEO HTML 生成器缓存架构                    │
├─────────────────────────────────────────────────────────────┤
│  1. HTML 文件缓存    - 文件系统 (哈希分层目录)                │
│  2. 站点配置缓存     - 内存 (sync.Map)                       │
│  3. 模板内容缓存     - 内存 (版本隔离)                        │
│  4. 编译模板缓存     - 内存 (字节码)                          │
│  5. 对象池          - 环形缓冲区 (原子操作)                   │
│  6. 数据池          - 内存 (按分组隔离)                       │
└─────────────────────────────────────────────────────────────┘
```

---

## 一、HTML 文件缓存 (HTMLCache)

### 文件位置

`api/internal/service/html_cache.go`

> **注意**: HTML 文件缓存完全由 Go API 管理，Python Worker 不参与 HTML 缓存操作。

### 设计原理

哈希分层目录结构，支持百万级文件存储：

```
html_cache/
├── _meta/                          # 元数据目录
│   └── example.com/
│       └── a1/b2/
│           └── {cache_key}.json   # 元数据: key, domain, path, size, created_at
│
└── example.com/                    # 域名目录
    └── a1/b2/                      # hash[0:2]/hash[2:4]
        ├── index.html              # 根路径
        ├── page.html               # 页面
        └── article/123.html        # 子目录页面
```

### 关键特性

| 特性 | 说明 |
|------|------|
| 哈希分层 | 支持百万级缓存文件，避免单目录性能瓶颈 |
| MD5 哈希 | `generateCacheKey(domain:path)` → hex string |
| 路径规范化 | 统一处理文件扩展名和目录结构 |
| 热更新 | 支持运行时重载缓存目录 |

### 核心接口

| 方法 | 功能 |
|------|------|
| `Set(domain, path, html)` | 存储 HTML |
| `Get(domain, path)` | 获取 HTML |
| `Delete(domain, path)` | 删除条目 |
| `Clear(domain)` | 清空缓存 |
| `Exists(domain, path)` | 检查存在 |
| `GetStats()` | 统计信息 |

### 动态配置

- `ReloadCacheDir(newDir)` - 热更新缓存目录
- 支持从数据库读取 `file_cache_dir` 配置

---

## 二、对象池 (ObjectPool)

### 文件位置

- Go: `api/internal/service/object_pool.go`
- Go: `api/internal/service/number_pool.go`
- Python: `content_worker/core/random_number_pool.py`

### 设计原理

环形缓冲区 + 原子操作 + 多线程生产者：

```
环形缓冲区设计:
┌──────────────────────────────────────────────────┐
│ pool[]                                            │
│ ↑                                                 │
│ └─ head (消费位置)           tail (生产位置)     │
│    (atomic)                   (atomic)            │
│                                                  │
│ available = tail - head                          │
│ used = capacity - available                      │
└──────────────────────────────────────────────────┘

低水位自动补充:
available < threshold → 启动后台 refill → 多线程并行补充
```

### 四种对象池

| 池名 | 用途 | 获取复杂度 |
|------|------|-----------|
| ClsPool | CSS 类名 | O(1) |
| URLPool | URL | O(1) |
| KeywordEmojiPool | 表情符号 | O(1) |
| NumberPool | 随机数 (15 个预定义范围) | O(1) |

### 关键参数

```go
type PoolConfig struct {
    Name          string              // 池名称
    Size          int                 // 容量
    LowWatermark  float64             // 低水位比例 (默认 0.4)
    RefillBatch   int                 // 每次补充数量
    NumWorkers    int                 // 生产者线程数
    CheckInterval time.Duration       // 检查间隔
}

// 典型配置
cfg := PoolConfig{
    Name:          "number_0-9",
    Size:          200000,
    LowWatermark:  0.4,              // 当可用 < 80000 时触发补充
    RefillBatch:   50000,            // 每次补充 50000 个
    NumWorkers:    8,                // 8 个线程并行生成
    CheckInterval: 30 * time.Millisecond,
}
```

### 核心接口

```go
// 核心操作
pool.Start()                    // 启动池
pool.Stop()                     // 停止池
obj := pool.Get()               // 获取对象 O(1)

// 管理操作
pool.Pause()                    // 暂停补充
pool.Resume()                   // 恢复补充
pool.Warmup(0.5)                // 预热到 50%
pool.Resize(500000)             // 调整容量
pool.Clear()                    // 清空池

// 查询操作
available := pool.Available()   // 可用数量
stats := pool.Stats()           // 详细统计
capacity := pool.Capacity()     // 容量
percent := pool.UsagePercent()  // 使用率
```

### 随机数池预定义范围

```go
ranges := map[string][2]int{
    "0-9":         {0, 9},
    "0-99":        {0, 99},
    "1-9":         {1, 9},
    "1-10":        {1, 10},
    "1-20":        {1, 20},
    "5-10":        {5, 10},
    "10-99":       {10, 99},
    "10-100":      {10, 100},
    "10-200":      {10, 200},
    "30-90":       {30, 90},
    "50-200":      {50, 200},
    "100-999":     {100, 999},
    "1000-9999":   {1000, 9999},
    "10000-99999": {10000, 99999},
}
```

---

## 三、数据池 (DataManager)

### 文件位置

`api/internal/service/data_manager.go`

### 设计原理

按 group_id 隔离，预编码优化：

```go
type DataManager struct {
    db           *sqlx.DB
    keywords     map[int][]string    // group_id -> 编码后关键词
    rawKeywords  map[int][]string    // group_id -> 原始关键词
    imageURLs    map[int][]string    // group_id -> 图片 URL
    titles       map[int][]string    // group_id -> 标题
    contents     map[int][]string    // group_id -> 正文
    encoder      *HTMLEntityEncoder  // HTML 编码器
    emojiManager *EmojiManager       // Emoji 管理
    mu           sync.RWMutex
}
```

### 关键特性

| 特性 | 说明 |
|------|------|
| 按分组隔离 | 每个 group_id 独立一份数据 |
| 预编码 | 关键词提前编码，加快渲染速度 |
| 原始数据保留 | rawKeywords 用于统计和分析 |
| Emoji 管理 | 集成 Emoji 处理 |

### 加载流程

```
LoadKeywords(ctx, groupID, limit)
  ↓
SELECT keyword FROM keywords WHERE group_id = ? LIMIT ?
  ↓
for each keyword:
  - 保存原始版本到 rawKeywords[groupID]
  - 编码到 keywords[groupID] (HTMLEntityEncoder)
  ↓
返回加载数量
```

### 统计接口

```go
type PoolStatusStats struct {
    Name        string     // 池名: "关键词池", "图片池" 等
    Size        int        // 总容量
    Available   int        // 可用数量
    Used        int        // 已使用数量
    Utilization float64    // 使用率 %
    Status      string     // "running", "paused"
    NumWorkers  int        // 工作线程数
    LastRefresh *time.Time // 最后更新时间
}
```

---

## 四、站点配置缓存 (SiteCache)

### 文件位置

`api/internal/service/site_cache.go`

### 设计原理

内存缓存 (sync.Map)，永久缓存无 TTL：

```go
type SiteCache struct {
    db    *sqlx.DB
    cache sync.Map          // domain -> *models.Site
    count int64
    mu    sync.RWMutex
}
```

### 生命周期

1. **启动阶段** - `LoadAll(ctx)` 加载所有活跃站点
2. **运行阶段** - `Get(ctx, domain)` 查询，不命中时从 DB 加载
3. **更新阶段** - `Reload(ctx, domain)` 单个站点更新，`ReloadAll(ctx)` 全量刷新
4. **失效机制** - `Invalidate(domain)` 手动失效，`InvalidateAll()` 清空

### 核心接口

| 方法 | 功能 |
|------|------|
| `LoadAll(ctx)` | 启动加载所有活跃站点 |
| `Get(ctx, domain)` | 查询 (内存优先，缓存 Miss 时加载) |
| `Reload(ctx, domain)` | 重新加载单个站点 |
| `ReloadAll(ctx)` | 重新加载所有站点 |
| `Invalidate(domain)` | 失效单个站点 |
| `InvalidateAll()` | 清空所有缓存 |

### 缓存失效触发

- API `/api/cache/site/reload/{domain}`
- API `/api/cache/site/reload`
- API `/api/cache/clear` (全量清理)

---

## 五、模板配置缓存 (TemplateCache)

### 文件位置

`api/internal/service/template_cache.go`

### 设计原理

内存缓存 (sync.Map)，支持版本管理：

```go
// 缓存键: "template_name:site_group_id"
key := cacheKey(name, siteGroupID)  // "list:1", "detail:2" 等

// 三层查询优先级:
1. 精确版本: name + siteGroupID
2. 默认版本: name + 1 (site_group_id == 1)
3. DB 查询: GetWithFallback()
```

### 关键特性

| 特性 | 说明 |
|------|------|
| 版本隔离 | 同一模板可有多个版本，按站点组隔离 |
| 回退机制 | 默认使用 group_id=1 作为全局通用版本 |
| 模板分析 | 集成 TemplateAnalyzer 进行变量分析 |

### 核心接口

| 方法 | 功能 |
|------|------|
| `LoadAll(ctx)` | 加载所有活跃模板 |
| `Get(name, siteGroupID)` | 查询 (内存，有版本回退) |
| `GetWithFallback(ctx, name, siteGroupID)` | 查询 (DB 回退) |
| `Reload(ctx, name, siteGroupID)` | 重新加载指定版本 |
| `ReloadByName(ctx, name)` | 重新加载所有版本 |
| `SetAnalyzer(analyzer)` | 设置模板分析器 |

### 缓存失效触发

- API `/api/cache/template/clear`
- API `/api/cache/template/reload`
- API `/api/cache/template/reload/{name}`

---

## 六、编译模板缓存 (TemplateRenderer)

### 设计原理

- 存储编译后的模板字节码
- 内存缓存，自动清理
- 当源模板变化时需手动清理
- `ClearCache()` 接口在模板更新时调用

---

## 七、缓存生命周期管理

### 启动加载

```
应用启动:
├── 1. 初始化各个缓存
│   ├── SiteCache.LoadAll(ctx) → 加载所有活跃站点
│   ├── TemplateCache.LoadAll(ctx) → 加载所有活跃模板
│   ├── DataManager.LoadKeywords(ctx, ...) → 加载关键词
│   ├── DataManager.LoadImages(ctx, ...) → 加载图片
│   ├── ObjectPool[int].Start() → 预填充随机数池
│   └── NumberPool.Start() → 启动后台补充
│
├── 2. 启动监听器
│   ├── PoolReloader.Start() → 监听 Redis pool:reload 频道
│   └── 其他实时推送服务
│
└── 3. 应用就绪
    └── 缓存预热完成
```

### 运行中更新

**触发点**:

1. **API 手动触发**:
   - `/api/cache/template/clear` → 模板内容变化
   - `/api/cache/clear` → 全量清理
   - `/api/cache/site/reload/{domain}` → 站点配置变化
   - `/api/admin/pool/config` → 池配置变化

2. **Redis 消息驱动**:
   - `pool:reload` 频道 → 动态调整池大小
   - PoolReloader 监听并应用

3. **后台自动刷新**:
   - DataManager 可配置自动刷新间隔
   - ObjectPool 低水位自动补充

### 失效策略

| 缓存类型 | 失效策略 | 触发条件 |
|---------|---------|--------|
| HTMLCache | 文件删除 + 元数据删除 | API 手动清理 / 定时过期 |
| SiteCache | 删除键 + 负缓存标记 | 站点删除 / 手动失效 |
| TemplateCache | 删除键 + 版本清理 | 模板删除 / 手动失效 |
| TemplateRenderer | 编译缓存清空 | 源模板变化 |
| ObjectPool | 环形缓冲区重置 | 手动调整 / 重启 |

---

## 八、缓存 API 接口

### Handler 层

**文件**: `api/internal/handler/cache.go`

**路由映射**:

```go
POST /api/cache/template/clear          // 清除模板内容缓存 + HTML 缓存
POST /api/cache/clear                   // 清除所有缓存
POST /api/cache/clear/:domain           // 清除域名特定缓存
POST /api/cache/site/reload             // 重新加载所有站点
POST /api/cache/site/reload/:domain     // 重新加载指定站点
POST /api/cache/template/reload         // 重新加载所有模板
POST /api/cache/template/reload/:name   // 重新加载指定模板 (支持 site_group_id)
GET  /api/cache/stats                   // 获取缓存统计
POST /api/cache/config/reload           // 动态重载缓存目录
```

### Pool 配置接口

**文件**: `api/internal/handler/pool_config.go`

```go
GET  /api/admin/pool/config              // 获取当前配置
POST /api/admin/pool/config              // 更新配置并发布 Redis 消息
```

**配置存储**: 数据库 `system_settings` 表

```sql
INSERT INTO system_settings (setting_key, setting_value) VALUES
('pool.concurrency_preset', 'medium'),
('pool.concurrency_custom', '200'),
('pool.buffer_seconds', '10');
```

**热更新流程**:

```
UpdateConfig(preset, concurrency, buffer_seconds)
  ↓
保存到数据库 (transaction)
  ↓
发布 Redis 消息到 pool:reload 频道
  ↓
Go PoolReloader 接收并调用 TemplateFuncs.ResizePools()
  ↓
Python Worker 的 PoolReloader 接收并记录
```

---

## 九、跨语言职责划分

### 架构概览

| 组件 | Go API | Python Worker |
|------|--------|---------------|
| HTML 文件缓存 | ✅ 完全管理 | ❌ 不参与 |
| 对象池 | ✅ 完全管理 | ❌ 不参与 |
| 数据池 | ✅ 完全管理 | ❌ 不参与 |
| 配置缓存 | ✅ 完全管理 | ❌ 不参与 |
| 模板渲染 | ✅ 完全管理 | ❌ 不参与 |
| 内容生成 | ❌ 不参与 | ✅ 完全管理 |
| 爬虫任务 | ❌ 不参与 | ✅ 完全管理 |

### Redis 协调机制

```
Go API 发布:
└── UpdatePoolConfig() → redis.Publish("pool:reload", msg)

Go 后端接收:
└── PoolReloader.listen() → ResizePools()

Python Worker 接收:
└── PoolReloader.listen() → log (暂无需调整)
```

### 架构图

```
┌─────────────┐    Redis pub/sub    ┌─────────────┐
│   Go API    │ ←─────────────────→ │ Python Worker│
└─────────────┘                     └─────────────┘
       │                                   │
       ↓                                   ↓
  ┌─────────┐                        ┌─────────┐
  │ HTML缓存 │                       │ 内容生成 │
  │ 数据池   │                       │ 爬虫任务 │
  │ 对象池   │                       │ 标题管理 │
  │ 模板渲染 │                       │ 正文管理 │
  └─────────┘                        └─────────┘
```

---

## 十、前端缓存管理界面

**文件**: `web/src/views/cache/CacheManage.vue`

### 页面结构

```
CacheManage.vue
├── Tab 1: 运行状态 (status)
│   ├── 数据池卡片 (DataPool)
│   ├── 对象池卡片 (ObjectPool) + 操作按钮
│   └── HTML 缓存卡片
│
└── Tab 2: 并发配置 (config)
    ├── 配置卡片
    │   ├── 预设等级选择
    │   ├── 自定义并发输入
    │   └── 缓冲时间设置
    └── 预估详情卡片
        ├── 模板基准统计
        └── 池大小预估
```

### WebSocket 实时推送

```typescript
// Tab 切换时建立/断开连接
watch(mainTab, (newTab) => {
  if (newTab === 'status') {
    connectPoolStatusWs()  // 建立连接
  } else {
    disconnectPoolStatusWs() // 断开连接
  }
})

// WebSocket URL
const wsUrl = `ws://${window.location.host}/ws/pool-status`
```

### 操作功能

| 按钮 | 功能 | API |
|------|------|-----|
| 刷新数据 | 强制刷新数据池 | `refreshDataPool('all')` |
| 预热 | 预热到 50% | `warmupPool(0.5)` |
| 暂停 | 暂停补充 | `pausePool()` |
| 恢复 | 恢复补充 | `resumePool()` |
| 清理 HTML | 清理所有 HTML 缓存 | `clearCache()` |
| 应用配置 | 保存并应用新配置 | `updatePoolConfig()` |

---

## 十一、池配置预设

**文件**: `api/internal/service/pool_presets.go`

```go
PoolPresets = map[string]PoolPreset{
    "low":     {Name: "低", Concurrency: 50},
    "medium":  {Name: "中", Concurrency: 200},
    "high":    {Name: "高", Concurrency: 500},
    "extreme": {Name: "极高", Concurrency: 1000},
}
```

**内存预估公式**:

```go
// 池大小计算
poolSize = maxStats × concurrency × bufferSeconds

// 内存估算 (字节)
memoryBytes = (cls×20 + url×100 + keyword_emoji×60 + number×8) × 1.2
// 1.2 系数考虑 Go 运行时开销
```

---

## 十二、性能特性总结

| 缓存类型 | 存储 | 获取 | 更新 | 特点 |
|---------|------|------|------|------|
| HTML 文件 | 文件 | O(1) | O(1) | 哈希分层 |
| 站点配置 | 内存 | O(1) | 手动 | sync.Map |
| 模板内容 | 内存 | O(1) | 版本 | 多版本隔离 |
| 对象池 | 环形缓冲 | O(1) | 自动 | 原子操作 |
| 数据池 | 内存 | O(1) | 刷新 | 按组隔离 |

---

## 十三、关键代码位置速查

| 功能 | Go 文件位置 |
|------|-----------|
| HTML 文件缓存 | `api/internal/service/html_cache.go` |
| 站点配置缓存 | `api/internal/service/site_cache.go` |
| 模板配置缓存 | `api/internal/service/template_cache.go` |
| 对象池 | `api/internal/service/object_pool.go` |
| 随机数池 | `api/internal/service/number_pool.go` |
| 数据池 | `api/internal/service/data_manager.go` |
| 缓存 Handler | `api/internal/handler/cache.go` |
| 池配置 Handler | `api/internal/handler/pool_config.go` |
| 池预设配置 | `api/internal/service/pool_presets.go` |
| 前端缓存管理 | `web/src/views/cache/CacheManage.vue` |

> **注意**: 所有缓存和模板渲染功能已完全迁移到 Go API。Python Worker 仅负责内容生成和爬虫任务，不参与缓存管理。

---

## 十四、扩展建议

1. **缓存分布式**: 考虑引入 Memcached/Redis 集中管理
2. **缓存预热**: 实现启动时的完整预热机制
3. **缓存过期**: 为 HTML 文件添加 TTL 机制
4. **监控告警**: 完善缓存命中率、池使用率告警
5. **缓存统计**: 增强缓存分析和优化工具
